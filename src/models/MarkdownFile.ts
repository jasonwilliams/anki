import { Uri, workspace, window, Position } from 'vscode';
import { EOL } from 'os';
import * as path from 'path';
import * as fs from 'fs';
import { Card } from './Card';


export class MarkdownFile {
  private readonly metaStart = `[//]: # (Autogenerated Anki Metadata -- delete to disable sync)`;
  private readonly metaEnd = `[//]: # (End Autogenerated Anki Metadata)`;
  public uri: Uri;
  public cachedContent: string;
  public noteIds: number[] = [];
  public autoSend: boolean = false;
  private meta: string = "";
  private isFromActiveEditor: boolean = false;

  constructor(uri: Uri | null) {
    if (uri) {
      this.uri = uri;
    } else {
      if (workspace.workspaceFolders && workspace.workspaceFolders.length > 0)
      {
        this.uri = workspace.workspaceFolders[0].uri;
      } else {
        this.uri = Uri.parse('.');
      }
    }    
    this.cachedContent = "";
  }

  private loadContent(content: string) {
    this.noteIds = this.readNoteIds(content);
    this.autoSend = this.readAutoSendMeta(content);
    this.cachedContent = this.removeMeta(
      this.extractMarkedText(content.toString())
    );
  }

  async load() {      
    try {
        const content = (await workspace.fs.readFile(this.uri)).toString();
        this.loadContent(content);
    }
    catch(e)
    {
        throw e;
    }
  }

  public dirPath()
  {
    return path.dirname(this.uri.fsPath);
  }



  private extractMarkedText(content: string): string {
    // Extract the text between markers - markdown comments <!-- BEGIN_ANKI_CARDS --> text <!-- END_ANKI_CARDS -->
    // Do a qucik test to see if the markers are present, otherwise return the whole content

    const beginMarker = "<!-- BEGIN_ANKI_CARDS -->";

    const begin = content.indexOf(beginMarker);

    if (begin === -1) {
      return content;
    }

    const regex = /<!-- BEGIN_ANKI_CARDS -->([\s\S]*?)<!-- END_ANKI_CARDS -->/gi;
    const matches = content.matchAll(regex);

    let result = "";
    for (const match of matches) {
      result += match[1] + EOL;
    }

    if (result === "") {
      window.showErrorMessage("Anki Markdown: No text found between BEGIN_ANKI_CARDS and END_ANKI_CARDS markers.");
    }

    return result;

  }

  private removeMeta(content: string) {
    const before = content.split(this.metaStart)[0];
    const endSplit = content.split(this.metaEnd);
    const after = endSplit.length > 1 ? endSplit[1] : "";
    // console.log(before);
    const removed = (before + after).trimEnd();
    return removed;
  }

  // TODO: make line breaks consistent with what's used in the file
  public async updateMeta(cards: Card[], autoSend: boolean) {
    this.autoSend = autoSend;
    const ids = cards.map(c => c.noteId ?? 0 );
    const metaBody = `[auto-send]: # (${this.autoSend ? "yes" : "no"})${EOL}[note-ids]: # (${ids.join(', ')})`;
    const meta = `${EOL}${EOL}${EOL}${this.metaStart}${EOL}${metaBody}${EOL}${this.metaEnd}${EOL}`;
    const content = this.cachedContent + meta;
    if (this.isFromActiveEditor) {
      await window.activeTextEditor?.document.save(); // cop-out. I editing the active editor in place without save
      // is a bit difficult. But I am not sure what the expected functionality would be.
      // Would a user expect to Send To Anki some unsaved data, and then make changes prior to saving...? I would think not.
      // Would a user be upset if the function Send To Anki saved his data?
    } 
    fs.writeFileSync(this.uri.fsPath, content);
  }

  private readNoteIds(content: string): number[] {
    const re = RegExp(/\[note-ids\]: # \((.+)\)/);
    const matches = content.match(re);
    if (matches) {
      return matches[1].split(', ').map(Number); // what is this wizardry
    }
    return [];
  }

  private readAutoSendMeta(content: string): boolean {
    const re = RegExp(/\[auto-send\]: # \((.+)\)/);
    const matches = content.match(re);
    if (matches) {
      return matches[1] == "yes"; // what is this wizardry
    }
    return false;
  }


  public static fromActiveTextEditor(): MarkdownFile
  {
    const uri = window.activeTextEditor?.document.uri;
    let file;
    if (uri) {
      file = new MarkdownFile(uri);
    } else {
      file = new MarkdownFile(null);
    }
    file.loadContent(window.activeTextEditor?.document.getText() ?? "");
    file.isFromActiveEditor = true;
    return file;
  }
}
