import { Uri, workspace, window, Position } from "vscode";
import { EOL } from "os";
import * as path from "path";
import * as fs from "fs";
import { Card } from "./Card";

export class MarkdownFile {
  private readonly metaStart = `[//]: # (Autogenerated Anki Metadata -- delete to disable sync)`;
  private readonly metaEnd = `[//]: # (End Autogenerated Anki Metadata)`;
  public uri: Uri;
  public cachedContent: string;
  public noteIds: number[] = [];
  public autoSend: boolean = false;
  private meta: string = "";
  private isFromActiveEditor: boolean = false;

  constructor(uri: Uri | null) {
    if (uri) {
      this.uri = uri;
    } else {
      if (workspace.workspaceFolders && workspace.workspaceFolders.length > 0) {
        this.uri = workspace.workspaceFolders[0].uri;
      } else {
        this.uri = Uri.parse(".");
      }
    }
    this.cachedContent = "";
  }

  private loadContent(content: string) {
    this.noteIds = this.readNoteIds(content);
    this.autoSend = this.readAutoSendMeta(content);
    this.cachedContent = this.removeMeta(content.toString());
  }

  async load() {
    try {
      const content = (await workspace.fs.readFile(this.uri)).toString();
      this.loadContent(content);
    } catch (e) {
      throw e;
    }
  }

  public dirPath() {
    return path.dirname(this.uri.fsPath);
  }

  private removeMeta(content: string) {
    const before = content.split(this.metaStart)[0];
    const endSplit = content.split(this.metaEnd);
    const after = endSplit.length > 1 ? endSplit[1] : "";
    // console.log(before);
    const removed = (before + after).trimEnd();
    return removed;
  }

  // TODO: make line breaks consistent with what's used in the file
  public async updateMeta(cards: Card[], autoSend: boolean) {
    this.autoSend = autoSend;
    const ids = cards.map((c) => c.noteId ?? 0);
    const metaBody = `[auto-send]: # (${this.autoSend ? "yes" : "no"})${EOL}[note-ids]: # (${ids.join(", ")})`;
    const meta = `${EOL}${EOL}${EOL}${this.metaStart}${EOL}${metaBody}${EOL}${this.metaEnd}${EOL}`;
    const content = this.cachedContent + meta;
    if (this.isFromActiveEditor) {
      await window.activeTextEditor?.document.save(); // cop-out. I editing the active editor in place without save
      // is a bit difficult. But I am not sure what the expected functionality would be.
      // Would a user expect to Send To Anki some unsaved data, and then make changes prior to saving...? I would think not.
      // Would a user be upset if the function Send To Anki saved his data?
    }
    fs.writeFileSync(this.uri.fsPath, content);
  }

  private readNoteIds(content: string): number[] {
    const re = RegExp(/\[note-ids\]: # \((.+)\)/);
    const matches = content.match(re);
    if (matches) {
      return matches[1].split(", ").map(Number); // what is this wizardry
    }
    return [];
  }

  private readAutoSendMeta(content: string): boolean {
    const re = RegExp(/\[auto-send\]: # \((.+)\)/);
    const matches = content.match(re);
    if (matches) {
      return matches[1] === "yes"; // what is this wizardry
    }
    return false;
  }

  public static fromActiveTextEditor(): MarkdownFile {
    const uri = window.activeTextEditor?.document.uri;
    let file;
    if (uri) {
      file = new MarkdownFile(uri);
    } else {
      file = new MarkdownFile(null);
    }
    file.loadContent(window.activeTextEditor?.document.getText() ?? "");
    file.isFromActiveEditor = true;
    return file;
  }
}
